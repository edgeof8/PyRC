<![CDATA[
                <h2>Architecture Overview</h2>
                <p class="lead">PyRC is built with a highly modular, event-driven architecture designed for extensibility, maintainability, and high performance, leveraging Python's <code>asyncio</code> framework for all I/O operations.</p>

                <div class="alert-box">
                    <strong>Design Philosophy:</strong> PyRC adheres to the principle of separation of concerns, with clear boundaries between components. A strong emphasis is placed on asynchronous operations, thread-safe state management, and a robust event dispatching system to ensure responsiveness and stability.
                </div>

                <h3>Overall Architecture Diagram</h3>
                <div class="diagram-container">
                    <div class="mermaid">
                    graph TD
                        A[pyrc.py] --> B(asyncio.run(IRCClient_Logic.run_main_loop()));
                        B --> C{IRCClient_Logic.run_main_loop() (async)};
                        C -- Creates --> D[asyncio.Task: NetworkHandler.network_loop (async)];
                        C -- Creates --> E[asyncio.Task: InputHandler.async_input_reader (async)];
                        D -- Reads/Writes data --> F(Async Network I/O - StreamReader/Writer);
                        D -- Dispatches messages --> G(irc_protocol.handle_server_message (async));
                        E -- Reads blocking input --> H(asyncio.to_thread(getch));
                        E -- Puts input into --> I(asyncio.Queue);
                        E -- Gets input from queue --> J(InputHandler.handle_key_press (async));
                        J -- Processes commands --> K(CommandHandler.process_user_command (async));
                        K -- Sends data --> D;
                        G -- Dispatches events --> L(EventManager.dispatch_event (async));
                        L -- Calls handlers --> M{ScriptManager.dispatch_event (async)};
                        M -- If async handler --> N(asyncio.create_task(handler(event_data)));
                        M -- If sync handler --> O(loop.run_in_executor(None, handler, event_data));
                        C -- Triggers periodically --> P(IRCClient_Logic._update_ui (async));
                        P -- Refreshes UI --> Q(UIManager.refresh_all_windows);
                    </div>
                </div>

                <h3>Key Architectural Features</h3>
                <div class="features-grid">
                    <div class="feature-card">
                        <h4>Asyncio-Based Core</h4>
                        <ul>
                            <li><strong>Complete Migration to asyncio:</strong> The entire client has been refactored to use Python's <code>asyncio</code> framework, eliminating the previous threading-based approach for better performance and simplified concurrency management.</li>
                            <li><strong>Non-blocking I/O:</strong> All network operations, user input handling, and UI updates are handled asynchronously, ensuring a responsive user experience even during heavy network traffic.</li>
                            <li><strong>Efficient Resource Usage:</strong> The single-threaded event loop model reduces context switching overhead and simplifies synchronization.</li>
                            <li><strong>Modern Python Features:</strong> Leverages Python 3.9+ features like <code>asyncio.to_thread</code> for running blocking operations without blocking the event loop.</li>
                        </ul>
                    </div>

                    <div class="feature-card">
                        <div class="feature-card">
                            <h4>Centralized State Management with <code>StateManager</code></h4>
                            <ul>
                                <li>The <code>StateManager</code> is the <em>exclusive</em> source of truth for all connection, session, and client-specific runtime state.</li>
                                <li>It provides thread-safe, persistent session state that includes:
                                    <ul>
                                        <li>Connection details (server, port, SSL status)</li>
                                        <li>Authentication state (SASL/NickServ info)</li>
                                        <li>Connection statistics and error history</li>
                                        <li>Joined channels and their states</li>
                                        <li>User preferences and client settings</li>
                                        <li>Message history and scrollback positions</li>
                                    </ul>
                                </li>
                                <li>State is automatically persisted to disk and restored on startup.</li>
                            </ul>
                            <div class="code-example">
                                <h5>Example State Access:</h5>
                                <pre><code># Get current connection info
    conn_info = client.state_manager.get_connection_info()
    if conn_info:
        print(f"Connected to {conn_info.server}:{conn_info.port}")

    # Subscribe to state changes
    def on_nick_change(change):
        print(f"Nick changed from {change.old_value} to {change.new_value}")

    client.state_manager.register_change_handler("nick", on_nick_change)</code></pre>
                            </div>
                        </div>
                    <div class="feature-card">
                        <h4>Dynamic Command System</h4>
                        <ul>
                            <li>All core client commands are implemented in individual Python modules within a structured <code>commands/</code> directory.</li>
                            <li>Commands are dynamically discovered using <code>pkgutil.walk_packages</code> and registered at startup, making the client easily extensible.</li>
                        </ul>
                    </div>

                    <div class="feature-card">
                        <h4>Extensible Scripting System</h4>
                        <ul>
                            <li>A powerful Python scripting system allows for deep customization.</li>
                            <li>Scripts can register commands, subscribe to a wide range of events, and interact with the client through a rich <code>ScriptAPIHandler</code>.</li>
                        </ul>
                    </div>

                    <div class="feature-card">
                        <h4>Modular Connection Management (<code>ConnectionOrchestrator</code>)</h4>
                        <ul>
                            <li>Introduced the <code>ConnectionOrchestrator</code> component to centralize and manage the entire server connection lifecycle.</li>
                            <li>Coordinates capability negotiation (<code>CapNegotiator</code>), authentication (<code>SaslAuthenticator</code>), and registration (<code>RegistrationHandler</code>).</li>
                            <li>Simplifies <code>IRCClient_Logic</code> by delegating complex connection state management and sequencing, leading to more robust and maintainable connection handling.</li>
                            <li>Implements comprehensive timeout mechanisms and error recovery for each connection phase.</li>
                        </ul>
                    </div>

                    <div class="feature-card">
                        <h4>Decomposed UI System</h4>
                        <ul>
                            <li>The previously monolithic <code>UIManager</code> has been refactored into a set of specialized components: <code>CursesManager</code>, <code>WindowLayoutManager</code>, <code>MessagePanelRenderer</code>, <code>SidebarPanelRenderer</code>, <code>StatusBarRenderer</code>, <code>InputLineRenderer</code>, and <code>SafeCursesUtils</code>.</li>
                            <li>This decomposition significantly improves separation of concerns, making the UI system more modular, testable, and easier to extend. <code>UIManager</code> now acts as an orchestrator for these components.</li>
                        </ul>
                    </div>
                </div>

                <h3>Detailed Connection Flow</h3>
                <p>The connection process in PyRC is orchestrated by the <code>ConnectionOrchestrator</code>, which ensures a robust and compliant connection to the IRC server.</p>
                <ol>
                    <li><strong>TCP/SSL Connection:</strong> Initiated by the <code>NetworkHandler</code>.</li>
                    <li><strong>CAP Negotiation:</strong> The <code>CapNegotiator</code> handles IRCv3 capabilities, requesting and confirming features like <code>sasl</code>, <code>multi-prefix</code>, and <code>message-tags</code>.</li>
                    <li><strong>SASL Authentication:</strong> If configured and supported, the <code>SaslAuthenticator</code> performs secure authentication (e.g., SASL PLAIN).</li>
                    <li><strong>NICK/USER Registration:</strong> The <code>RegistrationHandler</code> sends the NICK and USER commands to formally register the client with the server.</li>
                    <li><strong>Post-registration Actions:</strong> After successful registration (receiving RPL_WELCOME), PyRC proceeds with auto-joining channels and other startup tasks.</li>
                </ol>

                <h3>Component Interaction and Data Flow</h3>
                <div class="data-flow-diagram">
                    <div class="mermaid">
                    graph LR
                        A[NetworkHandler] -->|Raw IRC Messages| B(IRC Protocol Parser)
                        B -->|Parsed Events| C[EventManager]
                        C -->|Dispatched Events| D[Script Handlers]
                        C -->|Dispatched Events| E[StateManager]
                        E -->|State Changes| F[UI Manager]
                        G[InputHandler] -->|User Commands| H[CommandHandler]
                        H -->|IRC Commands| A
                        H -->|State Updates| E
                        D -->|API Calls| A
                        D -->|API Calls| E
                    </div>
                </div>
                <p>Data flows through PyRC via two main pathways:</p>
                <ol>
                    <li><strong>Server → Client:</strong>
                        <ul>
                            <li>Raw IRC messages are received by <code>NetworkHandler</code></li>
                            <li>Parsed by <code>irc_protocol.py</code> into structured events</li>
                            <li>Dispatched by <code>EventManager</code> to registered handlers</li>
                            <li>Handlers may update <code>StateManager</code> or trigger UI updates</li>
                        </ul>
                    </li>
                    <li><strong>User → Server:</strong>
                        <ul>
                            <li>Input captured by <code>InputHandler</code></li>
                            <li>Processed by <code>CommandHandler</code></li>
                            <li>Results in IRC commands sent via <code>NetworkHandler</code></li>
                            <li>Or state updates via <code>StateManager</code></li>
                        </ul>
                    </li>
                </ol>
                <div class="code-example">
                    <h5>Example Event Handling:</h5>
                    <pre><code># Script event handler
async def on_message(event_data):
    if "hello" in event_data["message"].lower():
        await api.send_message(
            event_data["target"],
            f"Hello {event_data['nick']}!"
        )

# Subscribe to PRIVMSG events
api.subscribe_event("PRIVMSG", on_message)</code></pre>
                </div>

            </article>
        </main>

        <footer>
            <p>PyRC &copy; 2025 | Open Source IRC Client | MIT Licensed</p>
        </footer>
    </div>
    <script>mermaid.initialize({startOnLoad:true});</script>
]]>
