<h2>Script API Reference</h2>
<p class="lead">Comprehensive reference for PyRC's Python scripting API, available to all loaded scripts as <code>self.api</code>.</p>

<div class="alert-box info">
    <i class="fas fa-info-circle"></i>
    <strong>Note:</strong> Most API methods are async and must be awaited.
</div>

<div class="api-section">
    <h3><i class="fas fa-plug"></i> Core API Methods</h3>

    <div class="method-card async-method">
        <div class="method-header">
            <h4><code>send_raw(message: str) -> Coroutine[None]</code></h4>
            <span class="async-badge">async</span>
        </div>
        <p>Sends a raw IRC message to the server. Must be awaited.</p>
        <div class="example">
            <h5>Example:</h5>
            <pre><code># In an async handler:
await self.api.send_raw("PRIVMSG #channel :Hello")

# Or in a synchronous handler:
await asyncio.to_thread(self.api.send_raw, "PRIVMSG #channel :Hello")</code></pre>
        </div>
        <div class="notes">
            <strong>Note:</strong> All network operations in PyRC are asynchronous.
            Scripts should use async handlers when possible for best performance.
        </div>
    </div>

    <div class="method-card">
        <h4><code>send_message(target: str, message: str) -> Coroutine[None]</code></h4>
        <p>Sends a PRIVMSG to a channel or user.</p>
        <pre><code>await self.api.send_message("#python", "Hello from script!")</code></pre>
    </div>

    <div class="method-card">
        <h4><code>register_command(name: str, handler: Callable, help_text: Dict[str, Any]) -> None</code></h4>
        <p>Registers a new client command.</p>
        <pre><code>self.api.register_command(
    name="greet",
    handler=self.handle_greet,
    help={
        "usage": "/greet [name]",
        "description": "Sends a greeting",
        "examples": ["/greet Alice"]
    }
)</code></pre>
    </div>
</div>

<div class="api-section">
    <h3><i class="fas fa-calendar-alt"></i> Event Subscription</h3>

    <div class="method-card">
        <h4><code>subscribe_event(event_type: str, handler: Callable) -> None</code></h4>
        <p>Subscribes to an event type.</p>
        <pre><code>def on_privmsg(event_data):
    print(f"Message from {event_data['nick']}")

self.api.subscribe_event("PRIVMSG", on_privmsg)</code></pre>
    </div>

    <div class="method-card">
        <h4><code>unsubscribe_event(event_type: str, handler: Callable) -> None</code></h4>
        <p>Unsubscribes from an event type.</p>
        <pre><code>self.api.unsubscribe_event("PRIVMSG", on_privmsg)</code></pre>
    </div>
</div>

<div class="api-section">
    <h3><i class="fas fa-exchange-alt"></i> DCC Operations</h3>

    <div class="method-card">
        <h4><code>dcc_send_file(nick: str, filepath: str, passive: bool = False) -> Coroutine[str]</code></h4>
        <p>Initiates a DCC file transfer.</p>
        <pre><code>transfer_id = await self.api.dcc_send_file("bob", "/path/to/file.txt")</code></pre>
    </div>

    <div class="method-card">
        <h4><code>dcc_accept_transfer(transfer_id: str, save_path: str) -> Coroutine[None]</code></h4>
        <p>Accepts an incoming DCC transfer.</p>
        <pre><code>await self.api.dcc_accept_transfer("dcc123", "/downloads/file.txt")</code></pre>
    </div>
</div>

<div class="script-template">
    <h3><i class="fas fa-file-code"></i> Script Template</h3>
    <pre><code>from pyrc_core.scripting.script_base import ScriptBase
import asyncio

class MyScript(ScriptBase):
    def on_load(self):
        """Called when script is loaded"""
        # Register commands
        self.api.register_command("test", self.handle_test)

        # Subscribe to events
        self.api.subscribe_event("PRIVMSG", self.on_message)
        self.api.subscribe_event("JOIN", self.on_join)

    async def handle_test(self, args_str: str):
        """Async command handler example"""
        try:
            context = self.api.get_active_context()
            await self.api.send_message(
                context,
                f"Test successful! Args: {args_str}"
            )
        except Exception as e:
            self.api.log_error(f"Error in test command: {e}")

    async def on_message(self, event_data: dict):
        """Async event handler for PRIVMSG"""
        if "hello" in event_data["message"].lower():
            await self.api.send_message(
                event_data["target"],
                f"Hello {event_data['nick']}!"
            )

    async def on_join(self, event_data: dict):
        """Async event handler for JOIN"""
        if event_data["nick"] == self.api.get_client_nick():
            await self.api.send_message(
                event_data["channel"],
                "Hello everyone! I'm a PyRC script."
            )

    def on_unload(self):
        """Clean up when script is unloaded"""
        self.api.unsubscribe_event("PRIVMSG", self.on_message)
        self.api.unsubscribe_event("JOIN", self.on_join)</code></pre>
                    <div class="async-notes">
                        <h4>Async Best Practices:</h4>
                        <ul>
                            <li>Use <code>async def</code> for handlers that make API calls</li>
                            <li>Always <code>await</code> API methods</li>
                            <li>Handle errors with try/except blocks</li>
                            <li>Clean up event subscriptions in <code>on_unload</code></li>
                        </ul>
                    </div>
                </div>
<div class="error-handling">
    <h3><i class="fas fa-bug"></i> Error Handling</h3>
    <p>Always handle errors in async operations:</p>
    <pre><code>try:
await self.api.send_message("#channel", "Hello")
except Exception as e:
self.api.log_error(f"Failed to send message: {e}")</code></pre>

    <h4>Script Lifecycle Management</h4>
    <pre><code>class MyScript(ScriptBase):
def on_load(self):
    """Initialize resources"""
    self.data = self.api.load_script_data("state.json") or {}

def on_unload(self):
    """Clean up resources"""
    self.api.save_script_data(self.data, "state.json")
    self.api.unsubscribe_all_events()</code></pre>

    <h4>Performance Optimization</h4>
    <ul>
        <li>Use async handlers for I/O operations</li>
        <li>Cache expensive operations</li>
        <li>Batch UI updates</li>
        <li>Monitor with <code>get_script_stats()</code></li>
    </ul>

    <h4>Troubleshooting</h4>
    <div class="alert-box warning">
        <i class="fas fa-exclamation-triangle"></i>
        <strong>Common Issues:</strong>
        <ul>
            <li>Missing <code>await</code> on async calls</li>
            <li>Unhandled exceptions in event handlers</li>
            <li>Resource leaks in long-running scripts</li>
            <li>Unsubscribed events causing memory leaks</li>
        </ul>
    </div>

    <h4>Advanced Event Handling</h4>
    <pre><code>async def on_message(self, event_data):
    try:
        if event_data["nick"] == self.api.get_client_nick():
            return  # Ignore our own messages

        if "!command" in event_data["message"]:
            parts = event_data["message"].split()
            if len(parts) > 1:
                await self.handle_command(parts[1], event_data)
    except Exception as e:
        self.api.log_error(f"Message handler error: {e}")
        await self.api.send_message(
            event_data["target"],
            "Error processing command"
        )</code></pre>
</div>

<div class="script-lifecycle">
    <h3><i class="fas fa-sync-alt"></i> Script Lifecycle</h3>
    <ol>
        <li><strong>Load</strong>: <code>on_load()</code> called - initialize resources</li>
        <li><strong>Active</strong>: Handles events/commands</li>
        <li><strong>Unload</strong>: <code>on_unload()</code> called - clean up</li>
        <li><strong>Reload</strong>: Script can be reloaded without restart</li>
    </ol>
</div>
